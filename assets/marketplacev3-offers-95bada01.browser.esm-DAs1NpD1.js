const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-4dSMX-rY.js","assets/index-Ch0Y1xiN.css"])))=>i.map(i=>d[i]);
var H=Object.defineProperty;var K=(u,t,r)=>t in u?H(u,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):u[t]=r;var d=(u,t,r)=>K(u,typeof t!="symbol"?t+"":t,r);import{ai as Z,a6 as F,B as s,a0 as g,s as m,bV as C,T as h,G as W,cm as y,h as T,am as I,aj as J,bF as M,cg as Q,bP as X,cH as N,ak as Y,ce as U,cI as z,a5 as tt,a2 as L,a4 as v,cJ as w,bW as R,a3 as S}from"./index-4dSMX-rY.js";import{c as O}from"./cleanCurrencyAddress-870d4ccc.browser.esm-DuPXs207.js";import{s as V}from"./setErc20Allowance-bae9b83c.browser.esm-DD2nPoyZ.js";import{g as k,h as E,i as rt}from"./marketplace-15a16d65.browser.esm-B6SEMVSy.js";import{f as $,I as et,c as at}from"./QueryParams-fe3080d5.browser.esm-DrkYkpMu.js";import{R as j,E as q}from"./assertEnabled-69ed68b5.browser.esm-a3yHtrnb.js";import{C as P,G as x}from"./contract-appuri-29f0e515.browser.esm-D-wpWxBY.js";import{C as D}from"./contract-interceptor-d7b164a7.browser.esm-C_yNedqZ.js";const G=L.object({assetContractAddress:v,tokenId:w,quantity:w.default(1),currencyContractAddress:v.default(R),pricePerToken:S,startTimestamp:j.default(new Date),endTimestamp:q,isReservedListing:L.boolean().default(!1)});let l=function(u){return u[u.UNSET=0]="UNSET",u[u.Created=1]="Created",u[u.Completed=2]="Completed",u[u.Cancelled=3]="Cancelled",u[u.Active=4]="Active",u[u.Expired=5]="Expired",u}({});class gt{constructor(t,r){d(this,"featureName",Z.name);d(this,"createListing",m(async t=>{const r=await G.parseAsync(t);await E(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await C(this.contractWrapper.getProvider(),r.pricePerToken,r.currencyContractAddress),n=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return r.startTimestamp.lt(n)&&(r.startTimestamp=s.from(n)),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:O(r.currencyContractAddress),pricePerToken:e,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp,reserved:r.isReservedListing}],parse:c=>({id:this.contractWrapper.parseLogs("NewListing",c==null?void 0:c.logs)[0].args.listingId,receipt:c})})}));d(this,"createListingsBatch",m(async t=>{const r=(await Promise.all(t.map(e=>this.createListing.prepare(e)))).map(e=>e.encode());return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:e=>this.contractWrapper.parseLogs("NewListing",e==null?void 0:e.logs).map(n=>({id:n.args.listingId,receipt:e}))})}));d(this,"updateListing",m(async(t,r)=>{const e=await G.parseAsync(r);await E(this.contractWrapper,this.getAddress(),e.assetContractAddress,e.tokenId,await this.contractWrapper.getSignerAddress());const a=await C(this.contractWrapper.getProvider(),e.pricePerToken,e.currencyContractAddress);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t,{assetContract:e.assetContractAddress,tokenId:e.tokenId,quantity:e.quantity,currency:O(e.currencyContractAddress),pricePerToken:a,startTimestamp:e.startTimestamp,endTimestamp:e.endTimestamp,reserved:e.isReservedListing}],parse:n=>({id:this.contractWrapper.parseLogs("UpdatedListing",n==null?void 0:n.logs)[0].args.listingId,receipt:n})})}));d(this,"cancelListing",m(async t=>h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelListing",args:[t]})));d(this,"buyFromListing",m(async(t,r,e)=>{e&&(e=await g(e));const a=await this.validateListing(s.from(t)),{valid:n,error:c}=await this.isStillValidListing(a,r);if(!n)throw new Error(`Listing ${t} is no longer valid. ${c}`);const i=e||await this.contractWrapper.getSignerAddress(),o=s.from(r),p=s.from(a.pricePerToken).mul(o),f=await this.contractWrapper.getCallOverrides()||{};return await V(this.contractWrapper,p,a.currencyContractAddress,f),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buyFromListing",args:[t,i,o,a.currencyContractAddress,p],overrides:f})}));d(this,"approveBuyerForReservedListing",m(async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r))throw new Error(`Buyer ${r} already approved for listing ${t}.`);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!0]})}));d(this,"revokeBuyerApprovalForReservedListing",m(async(t,r)=>{if(await this.isBuyerApprovedForListing(t,r))return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveBuyerForListing",args:[t,r,!1]});throw new Error(`Buyer ${r} not approved for listing ${t}.`)}));d(this,"approveCurrencyForListing",m(async(t,r,e)=>{const a=await this.validateListing(s.from(t)),n=await g(r);n===a.currencyContractAddress&&W(e===a.pricePerToken);const c=await this.contractWrapper.read("currencyPriceForListing",[t,n]);return W(e===c),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,n,e]})}));d(this,"revokeCurrencyApprovalForListing",m(async(t,r)=>{const e=await this.validateListing(s.from(t)),a=await g(r);if(a===e.currencyContractAddress)throw new Error("Can't revoke approval for main listing currency.");const n=await this.contractWrapper.read("currencyPriceForListing",[t,a]);return W(!n.isZero()),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"approveCurrencyForListing",args:[t,a,s.from(0)]})}));this.contractWrapper=t,this.storage=r,this.events=new P(this.contractWrapper),this.encoder=new F(this.contractWrapper),this.interceptor=new D(this.contractWrapper),this.estimator=new x(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async getAll(t){const r=await this.getTotalCount(),e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No listings exist on the contract.");let n=[];n=(await k(e,a,(o,p)=>this.contractWrapper.read("getAllListings",[o,p]))).flat();const i=await this.applyFilter(n,t);return await Promise.all(i.map(o=>this.mapListing(o)))}async getAllValid(t){const r=await this.getTotalCount(),e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No listings exist on the contract.");let n=[];n=(await k(e,a,(o,p)=>this.contractWrapper.read("getAllValidListings",[o,p]))).flat();const i=await this.applyFilter(n,t);return await Promise.all(i.map(o=>this.mapListing(o)))}async getListing(t){const r=await this.contractWrapper.read("getListing",[t]);return await this.mapListing(r)}async isBuyerApprovedForListing(t,r){if(!(await this.validateListing(s.from(t))).isReservedListing)throw new Error(`Listing ${t} is not a reserved listing.`);return await this.contractWrapper.read("isBuyerApprovedForListing",[t,await g(r)])}async isCurrencyApprovedForListing(t,r){return await this.validateListing(s.from(t)),await this.contractWrapper.read("isCurrencyApprovedForListing",[t,await g(r)])}async currencyPriceForListing(t,r){const e=await this.validateListing(s.from(t)),a=await g(r);if(a===e.currencyContractAddress)return e.pricePerToken;if(!await this.isCurrencyApprovedForListing(t,a))throw new Error(`Currency ${a} is not approved for Listing ${t}.`);return await this.contractWrapper.read("currencyPriceForListing",[t,a])}async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){let r=l.UNSET;const a=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=s.from(t.startTimestamp).gt(a)?l.Created:s.from(t.endTimestamp).lt(a)?l.Expired:l.Active;break;case 2:r=l.Completed;break;case 3:r=l.Cancelled;break}return{assetContractAddress:t.assetContract,currencyContractAddress:t.currency,pricePerToken:t.pricePerToken.toString(),currencyValuePerToken:await y(this.contractWrapper.getProvider(),t.currency,t.pricePerToken),id:t.listingId.toString(),tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),startTimeInSeconds:s.from(t.startTimestamp).toNumber(),asset:await $(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:s.from(t.endTimestamp).toNumber(),creatorAddress:t.listingCreator,isReservedListing:t.reserved,status:r}}async isStillValidListing(t,r){if(!await rt(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.creatorAddress))return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};const a=this.contractWrapper.getProvider(),n=(await T(async()=>{const{default:p}=await import("./IERC165-bKJSsN7u.js");return{default:p}},[])).default,c=new I(t.assetContractAddress,n,a),i=await c.supportsInterface(et),o=await c.supportsInterface(at);if(i){const p=(await T(async()=>{const{default:B}=await import("./index-4dSMX-rY.js").then(_=>_.is);return{default:B}},__vite__mapDeps([0,1]))).default,f=new I(t.assetContractAddress,p,a);let A;try{A=await f.ownerOf(t.tokenId)}catch{}const b=(A==null?void 0:A.toLowerCase())===t.creatorAddress.toLowerCase();return{valid:b,error:b?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}else if(o){const p=(await T(async()=>{const{default:B}=await import("./index-4dSMX-rY.js").then(_=>_.iu);return{default:B}},__vite__mapDeps([0,1]))).default,b=(await new I(t.assetContractAddress,p,a).balanceOf(t.creatorAddress,t.tokenId)).gte(r||t.quantity);return{valid:b,error:b?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}else return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){const a=await g(r.seller);e=e.filter(n=>n.listingCreator.toString().toLowerCase()===(a==null?void 0:a.toString().toLowerCase()))}if(r.tokenContract){const a=await g(r.tokenContract);e=e.filter(n=>n.assetContract.toString().toLowerCase()===(a==null?void 0:a.toString().toLowerCase()))}r.tokenId!==void 0&&(e=e.filter(a=>{var n;return a.tokenId.toString()===((n=r==null?void 0:r.tokenId)==null?void 0:n.toString())}))}return r!=null&&r.count&&r.count<e.length?e.slice(0,r.count):e}}const nt=L.object({assetContractAddress:v,tokenId:w,quantity:w.default(1),currencyContractAddress:v.default(R),minimumBidAmount:S,buyoutBidAmount:S,timeBufferInSeconds:w.default(900),bidBufferBps:w.default(500),startTimestamp:j.default(new Date),endTimestamp:q});class wt{constructor(t,r){d(this,"featureName",J.name);d(this,"createAuction",m(async t=>{const r=nt.parse(t);await E(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress());const e=await C(this.contractWrapper.getProvider(),r.buyoutBidAmount,r.currencyContractAddress),a=await C(this.contractWrapper.getProvider(),r.minimumBidAmount,r.currencyContractAddress),c=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return r.startTimestamp.lt(c)&&(r.startTimestamp=s.from(c)),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createAuction",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:O(r.currencyContractAddress),minimumBidAmount:a,buyoutBidAmount:e,timeBufferInSeconds:r.timeBufferInSeconds,bidBufferBps:r.bidBufferBps,startTimestamp:r.startTimestamp,endTimestamp:r.endTimestamp}],parse:i=>({id:this.contractWrapper.parseLogs("NewAuction",i.logs)[0].args.auctionId,receipt:i})})}));d(this,"createAuctionsBatch",m(async t=>{const r=(await Promise.all(t.map(e=>this.createAuction.prepare(e)))).map(e=>e.encode());return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:e=>this.contractWrapper.parseLogs("NewAuction",e==null?void 0:e.logs).map(n=>({id:n.args.auctionId,receipt:e}))})}));d(this,"buyoutAuction",m(async t=>{const r=await this.validateAuction(s.from(t)),e=await Q(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid.prepare(t,X(r.buyoutBidAmount,e.decimals))}));d(this,"makeBid",m(async(t,r)=>{const e=await this.validateAuction(s.from(t)),a=await C(this.contractWrapper.getProvider(),r,e.currencyContractAddress);if(a.eq(s.from(0)))throw new Error("Cannot make a bid with 0 value");if(s.from(e.buyoutBidAmount).gt(0)&&a.gt(e.buyoutBidAmount))throw new Error("Bid amount must be less than or equal to buyoutBidAmount");if(await this.getWinningBid(t)){const i=await this.isWinningBid(t,a);W(i)}else{const i=a,o=s.from(e.minimumBidAmount);W(i.gte(o))}const c=await this.contractWrapper.getCallOverrides()||{};return await V(this.contractWrapper,a,e.currencyContractAddress,c),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"bidInAuction",args:[t,a],overrides:c})}));d(this,"cancelAuction",m(async t=>{if(await this.getWinningBid(t))throw new Error("Bids already made.");return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelAuction",args:[t]})}));d(this,"closeAuctionForBidder",m(async(t,r)=>{r||(r=await this.contractWrapper.getSignerAddress());const e=await this.validateAuction(s.from(t));try{return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionTokens",args:[s.from(t)]})}catch(a){throw a.message.includes("Marketplace: auction still active.")?new N(t.toString(),e.endTimeInSeconds.toString()):a}}));d(this,"closeAuctionForSeller",m(async t=>{const r=await this.validateAuction(s.from(t));try{return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"collectAuctionPayout",args:[s.from(t)]})}catch(e){throw e.message.includes("Marketplace: auction still active.")?new N(t.toString(),r.endTimeInSeconds.toString()):e}}));d(this,"executeSale",m(async t=>{const r=await this.validateAuction(s.from(t));try{const e=await this.getWinningBid(t);W(e,"No winning bid found");const a=this.encoder.encode("collectAuctionPayout",[t]),n=this.encoder.encode("collectAuctionTokens",[t]);return h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[[a,n]]})}catch(e){throw e.message.includes("Marketplace: auction still active.")?new N(t.toString(),r.endTimeInSeconds.toString()):e}}));this.contractWrapper=t,this.storage=r,this.events=new P(this.contractWrapper),this.encoder=new F(this.contractWrapper),this.interceptor=new D(this.contractWrapper),this.estimator=new x(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalAuctions",[])}async getAll(t){const r=await this.getTotalCount(),e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No auctions exist on the contract.");let n=[];n=(await k(e,a,(o,p)=>this.contractWrapper.read("getAllAuctions",[o,p]))).flat();const i=await this.applyFilter(n,t);return await Promise.all(i.map(o=>this.mapAuction(o)))}async getAllValid(t){const r=await this.getTotalCount(),e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No auctions exist on the contract.");let n=[];n=(await k(e,a,(o,p)=>this.contractWrapper.read("getAllValidAuctions",[o,p]))).flat();const i=await this.applyFilter(n,t);return await Promise.all(i.map(o=>this.mapAuction(o)))}async getAuction(t){const r=await this.contractWrapper.read("getAuction",[t]);return await this.mapAuction(r)}async getWinningBid(t){await this.validateAuction(s.from(t));const r=await this.contractWrapper.read("getWinningBid",[t]);if(r._bidder!==M)return await this.mapBid(t.toString(),r._bidder,r._currency,r._bidAmount.toString())}async isWinningBid(t,r){return await this.contractWrapper.read("isNewWinningBid",[t,r])}async getWinner(t){const r=await this.validateAuction(s.from(t)),e=await this.contractWrapper.read("getWinningBid",[t]),a=s.from(Math.floor(Date.now()/1e3)),n=s.from(r.endTimeInSeconds);if(a.gt(n)&&e._bidder!==M)return e._bidder;const o=(await new P(this.contractWrapper).getEvents("AuctionClosed")).find(p=>p.data.auctionId.eq(s.from(t)));if(!o)throw new Error(`Could not find auction with ID ${t} in closed auctions`);return o.data.winningBidder}async getBidBufferBps(t){return(await this.getAuction(t)).bidBufferBps}async getMinimumNextBid(t){const[r,e,a]=await Promise.all([this.getBidBufferBps(t),this.getWinningBid(t),this.validateAuction(s.from(t))]),n=e?s.from(e.bidAmount):s.from(a.minimumBidAmount),c=n.add(n.mul(r).div(1e4));return y(this.contractWrapper.getProvider(),a.currencyContractAddress,c)}async validateAuction(t){try{return await this.getAuction(t)}catch(r){throw console.error(`Error getting the auction with id ${t}`),r}}async mapAuction(t){let r=l.UNSET;const a=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=s.from(t.startTimestamp).gt(a)?l.Created:s.from(t.endTimestamp).lt(a)?l.Expired:l.Active;break;case 2:r=l.Completed;break;case 3:r=l.Cancelled;break}return{id:t.auctionId.toString(),creatorAddress:t.auctionCreator,assetContractAddress:t.assetContract,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),currencyContractAddress:t.currency,minimumBidAmount:t.minimumBidAmount.toString(),minimumBidCurrencyValue:await y(this.contractWrapper.getProvider(),t.currency,t.minimumBidAmount),buyoutBidAmount:t.buyoutBidAmount.toString(),buyoutCurrencyValue:await y(this.contractWrapper.getProvider(),t.currency,t.buyoutBidAmount),timeBufferInSeconds:s.from(t.timeBufferInSeconds).toNumber(),bidBufferBps:s.from(t.bidBufferBps).toNumber(),startTimeInSeconds:s.from(t.startTimestamp).toNumber(),endTimeInSeconds:s.from(t.endTimestamp).toNumber(),asset:await $(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),status:r}}async mapBid(t,r,e,a){const n=await g(r),c=await g(e);return{auctionId:t,bidderAddress:n,currencyContractAddress:c,bidAmount:a,bidAmountCurrencyValue:await y(this.contractWrapper.getProvider(),c,a)}}async applyFilter(t,r){let e=[...t];if(r){if(r.seller){const a=await g(r.seller);e=e.filter(n=>n.auctionCreator.toString().toLowerCase()===(a==null?void 0:a.toString().toLowerCase()))}if(r.tokenContract){const a=await g(r.tokenContract);e=e.filter(n=>n.assetContract.toString().toLowerCase()===(a==null?void 0:a.toString().toLowerCase()))}r.tokenId!==void 0&&(e=e.filter(a=>{var n;return a.tokenId.toString()===((n=r==null?void 0:r.tokenId)==null?void 0:n.toString())}))}return r!=null&&r.count&&r.count<e.length?e.slice(0,r.count):e}}const st=L.object({assetContractAddress:v,tokenId:w,quantity:w.default(1),currencyContractAddress:v.default(R),totalPrice:S,endTimestamp:q});class ft{constructor(t,r){d(this,"featureName",Y.name);d(this,"makeOffer",m(async t=>{const r=await st.parseAsync(t),e=await this.contractWrapper.getChainID(),a=U(r.currencyContractAddress)?z[e].wrapped.address:r.currencyContractAddress,n=await C(this.contractWrapper.getProvider(),r.totalPrice,a),c=await this.contractWrapper.getCallOverrides();return await V(this.contractWrapper,n,a,c),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"makeOffer",args:[{assetContract:r.assetContractAddress,tokenId:r.tokenId,quantity:r.quantity,currency:a,totalPrice:n,expirationTimestamp:r.endTimestamp}],parse:i=>({id:this.contractWrapper.parseLogs("NewOffer",i==null?void 0:i.logs)[0].args.offerId,receipt:i})})}));d(this,"cancelOffer",m(async t=>h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelOffer",args:[t]})));d(this,"acceptOffer",m(async t=>{const r=await this.validateOffer(s.from(t)),{valid:e,error:a}=await this.isStillValidOffer(r);if(!e)throw new Error(`Offer ${t} is no longer valid. ${a}`);const n=await this.contractWrapper.getCallOverrides()||{};return await E(this.contractWrapper,this.getAddress(),r.assetContractAddress,r.tokenId,await this.contractWrapper.getSignerAddress()),h.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t],overrides:n})}));this.contractWrapper=t,this.storage=r,this.events=new P(this.contractWrapper),this.encoder=new F(this.contractWrapper),this.interceptor=new D(this.contractWrapper),this.estimator=new x(this.contractWrapper)}getAddress(){return this.contractWrapper.address}async getTotalCount(){return await this.contractWrapper.read("totalOffers",[])}async getAll(t){const r=await this.getTotalCount(),e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No offers exist on the contract.");let n=[];n=(await k(e,a,(o,p)=>this.contractWrapper.read("getAllOffers",[o,p]))).flat();const i=await this.applyFilter(n,t);return await Promise.all(i.map(o=>this.mapOffer(o)))}async getAllValid(t){const r=await this.getTotalCount(),e=s.from((t==null?void 0:t.start)||0).toNumber(),a=r.toNumber();if(a===0)throw new Error("No offers exist on the contract.");let n=[];n=(await k(e,a,(o,p)=>this.contractWrapper.read("getAllValidOffers",[o,p]))).flat();const i=await this.applyFilter(n,t);return await Promise.all(i.map(o=>this.mapOffer(o)))}async getOffer(t){const r=await this.contractWrapper.read("getOffer",[t]);return await this.mapOffer(r)}async validateOffer(t){try{return await this.getOffer(t)}catch(r){throw console.error(`Error getting the offer with id ${t}`),r}}async mapOffer(t){let r=l.UNSET;const a=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;switch(t.status){case 1:r=s.from(t.expirationTimestamp).lt(a)?l.Expired:l.Active;break;case 2:r=l.Completed;break;case 3:r=l.Cancelled;break}return{id:t.offerId.toString(),offerorAddress:t.offeror,assetContractAddress:t.assetContract,currencyContractAddress:t.currency,tokenId:t.tokenId.toString(),quantity:t.quantity.toString(),totalPrice:t.totalPrice.toString(),currencyValue:await y(this.contractWrapper.getProvider(),t.currency,t.totalPrice),asset:await $(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),endTimeInSeconds:s.from(t.expirationTimestamp).toNumber(),status:r}}async isStillValidOffer(t){if(s.from(Math.floor(Date.now()/1e3)).gt(t.endTimeInSeconds))return{valid:!1,error:`Offer with ID ${t.id} has expired`};const e=await this.contractWrapper.getChainID(),a=U(t.currencyContractAddress)?z[e].wrapped.address:t.currencyContractAddress,n=this.contractWrapper.getProvider(),c=(await T(async()=>{const{default:f}=await import("./index-4dSMX-rY.js").then(A=>A.ir);return{default:f}},__vite__mapDeps([0,1]))).default,i=new tt(n,a,c,{},this.storage);return(await i.read("balanceOf",[t.offerorAddress])).lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} doesn't have enough balance of token ${a}`}:(await i.read("allowance",[t.offerorAddress,this.getAddress()])).lt(t.totalPrice)?{valid:!1,error:`Offeror ${t.offerorAddress} hasn't approved enough amount of token ${a}`}:{valid:!0,error:""}}async applyFilter(t,r){let e=[...t];if(r){if(r.offeror){const a=await g(r.offeror);e=e.filter(n=>n.offeror.toString().toLowerCase()===(a==null?void 0:a.toString().toLowerCase()))}if(r.tokenContract){const a=await g(r.tokenContract);e=e.filter(n=>n.assetContract.toString().toLowerCase()===(a==null?void 0:a.toString().toLowerCase()))}r.tokenId!==void 0&&(e=e.filter(a=>{var n;return a.tokenId.toString()===((n=r==null?void 0:r.tokenId)==null?void 0:n.toString())}))}return r!=null&&r.count&&r.count<e.length?e.slice(0,r.count):e}}export{gt as M,wt as a,ft as b};
