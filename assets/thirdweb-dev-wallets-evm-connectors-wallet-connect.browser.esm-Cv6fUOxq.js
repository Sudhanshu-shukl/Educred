const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index.es-PlC50otA.js","assets/index-4dSMX-rY.js","assets/index-Ch0Y1xiN.css"])))=>i.map(i=>d[i]);
import{W as Q,d as p,a as u,w as z,_ as I,e as y,c as n,k as r,b as N,f as U,U as L,S as k,i as q,h as K}from"./index-4dSMX-rY.js";import{g as Y}from"./url-a45219bd.browser.esm-CnlspJ3o.js";const $=new Set([1,137,10,42161,56]),x="eip155",j="wagmi.requestedChains",A="wallet_addEthereumChain",P="last-used-chain-id";var a=new WeakMap,_=new WeakMap,m=new WeakMap,S=new WeakSet,E=new WeakSet,M=new WeakSet,g=new WeakSet,D=new WeakSet,W=new WeakSet,O=new WeakSet;class Z extends Q{constructor(e){super({...e,options:{isNewChainsStale:!0,...e.options}}),p(this,O),p(this,W),p(this,D),p(this,g),p(this,M),p(this,E),p(this,S),u(this,"id",z.walletConnect),u(this,"name","WalletConnect"),u(this,"ready",!0),I(this,a,{writable:!0,value:void 0}),I(this,_,{writable:!0,value:void 0}),I(this,m,{writable:!0,value:void 0}),u(this,"onAccountsChanged",t=>{t.length===0?this.emit("disconnect"):t[0]&&this.emit("change",{account:y(t[0])})}),u(this,"onChainChanged",async t=>{const i=Number(t),s=this.isChainUnsupported(i);await n(this,m).setItem(P,String(t)),this.emit("change",{chain:{id:i,unsupported:s}})}),u(this,"onDisconnect",async()=>{await r(this,g,v).call(this,[]),await n(this,m).removeItem(P),this.emit("disconnect")}),u(this,"onDisplayUri",t=>{this.emit("message",{type:"display_uri",data:t})}),u(this,"onConnect",()=>{this.emit("connect",{provider:n(this,a)})}),N(this,m,e.options.storage),r(this,S,T).call(this),this.filteredChains=this.chains.length>50?this.chains.filter(t=>$.has(t.chainId)):this.chains,this.showWalletConnectModal=this.options.qrcode!==!1}async connect(){var i;let{chainId:e,pairingTopic:t}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};try{let s=e;if(!s){const C=await n(this,m).getItem(P),d=C?parseInt(C):void 0;d&&!this.isChainUnsupported(d)?s=d:s=(i=this.filteredChains[0])==null?void 0:i.chainId}if(!s)throw new Error("No chains found on connector.");const o=await this.getProvider();this.setupListeners();const h=await r(this,E,b).call(this);if(o.session&&h&&await o.disconnect(),!o.session||h){const C=this.filteredChains.filter(d=>d.chainId!==s).map(d=>d.chainId);this.emit("message",{type:"connecting"}),await o.connect({pairingTopic:t,chains:[s],optionalChains:C.length>0?C:[s]}),await r(this,g,v).call(this,this.filteredChains.map(d=>{let{chainId:J}=d;return J}))}const c=await o.enable();if(!c[0])throw new Error("No accounts found on provider.");const w=y(c[0]),f=await this.getChainId(),G=this.isChainUnsupported(f);return{account:w,chain:{id:f,unsupported:G},provider:new U(o)}}catch(s){throw/user rejected/i.test(s==null?void 0:s.message)?new L(s):s}}async disconnect(){const e=()=>{if(!(typeof localStorage>"u"))for(const s in localStorage)s.startsWith("wc@2")&&localStorage.removeItem(s)};e();const t=await this.getProvider();(async()=>{try{await t.disconnect()}catch(s){if(!/No matching key/i.test(s.message))throw s}finally{r(this,M,R).call(this),await r(this,g,v).call(this,[]),e()}})()}async getAccount(){const{accounts:e}=await this.getProvider();if(!e[0])throw new Error("No accounts found on provider.");return y(e[0])}async getChainId(){const{chainId:e}=await this.getProvider();return e}async getProvider(){let{chainId:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};if(n(this,a)||await r(this,S,T).call(this),e&&await this.switchChain(e),!n(this,a))throw new Error("No provider found.");return n(this,a)}async getSigner(){let{chainId:e}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};const[t,i]=await Promise.all([this.getProvider({chainId:e}),this.getAccount()]);return new U(t,e).getSigner(i)}async isAuthorized(){try{const[e,t]=await Promise.all([this.getAccount(),this.getProvider()]),i=await r(this,E,b).call(this);if(!e)return!1;if(i&&t.session){try{await t.disconnect()}catch{}return!1}return!0}catch{return!1}}async switchChain(e){const t=this.chains.find(i=>i.chainId===e);if(!t)throw new k(`Chain with ID: ${e}, not found on connector.`);try{const i=await this.getProvider(),s=r(this,W,V).call(this),o=r(this,O,F).call(this);if(!s.includes(e)&&o.includes(A)){const c=t.explorers&&t.explorers[0],w=c?{blockExplorerUrls:[c.url]}:{};await i.request({method:A,params:[{chainId:q(t.chainId),chainName:t.name,nativeCurrency:t.nativeCurrency,rpcUrls:Y(t),...w}]});const f=await r(this,D,H).call(this);f.push(e),await r(this,g,v).call(this,f)}return await i.request({method:"wallet_switchEthereumChain",params:[{chainId:q(e)}]}),t}catch(i){const s=typeof i=="string"?i:i==null?void 0:i.message;throw/user rejected request/i.test(s)?new L(i):new k(i)}}async initProvider(){const{default:e,OPTIONAL_EVENTS:t,OPTIONAL_METHODS:i}=await K(async()=>{const{default:h,OPTIONAL_EVENTS:c,OPTIONAL_METHODS:w}=await import("./index.es-PlC50otA.js");return{default:h,OPTIONAL_EVENTS:c,OPTIONAL_METHODS:w}},__vite__mapDeps([0,1,2])),[s,...o]=this.filteredChains.map(h=>{let{chainId:c}=h;return c});s&&N(this,a,await e.init({showQrModal:this.showWalletConnectModal,projectId:this.options.projectId,optionalMethods:i,optionalEvents:t,chains:[s],optionalChains:o,metadata:{name:this.options.dappMetadata.name,description:this.options.dappMetadata.description||"",url:this.options.dappMetadata.url,icons:[this.options.dappMetadata.logoUrl||""]},rpcMap:Object.fromEntries(this.filteredChains.map(h=>[h.chainId,h.rpc[0]||""])),qrModalOptions:this.options.qrModalOptions}))}async setupListeners(){n(this,a)&&(r(this,M,R).call(this),n(this,a).on("accountsChanged",this.onAccountsChanged),n(this,a).on("chainChanged",this.onChainChanged),n(this,a).on("disconnect",this.onDisconnect),n(this,a).on("session_delete",this.onDisconnect),n(this,a).on("display_uri",this.onDisplayUri),n(this,a).on("connect",this.onConnect))}}async function T(){return n(this,_)||N(this,_,this.initProvider()),n(this,_)}async function b(){if(r(this,O,F).call(this).includes(A)||!this.options.isNewChainsStale)return!1;const e=await r(this,D,H).call(this),t=this.filteredChains.map(s=>{let{chainId:o}=s;return o}),i=r(this,W,V).call(this);return i.length&&!i.some(s=>t.includes(s))?!1:!t.every(s=>e.includes(s))}function R(){n(this,a)&&(n(this,a).removeListener("accountsChanged",this.onAccountsChanged),n(this,a).removeListener("chainChanged",this.onChainChanged),n(this,a).removeListener("disconnect",this.onDisconnect),n(this,a).removeListener("session_delete",this.onDisconnect),n(this,a).removeListener("display_uri",this.onDisplayUri),n(this,a).removeListener("connect",this.onConnect))}async function v(l){await n(this,m).setItem(j,JSON.stringify(l))}async function H(){const l=await n(this,m).getItem(j);return l?JSON.parse(l):[]}function V(){var e,t,i;return n(this,a)?((i=(t=(e=n(this,a).session)==null?void 0:e.namespaces[x])==null?void 0:t.chains)==null?void 0:i.map(s=>parseInt(s.split(":")[1]||"")))??[]:[]}function F(){var e,t;return n(this,a)?((t=(e=n(this,a).session)==null?void 0:e.namespaces[x])==null?void 0:t.methods)??[]:[]}export{Z as WalletConnectConnector};
