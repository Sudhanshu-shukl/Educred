const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-4dSMX-rY.js","assets/index-Ch0Y1xiN.css"])))=>i.map(i=>d[i]);
import{cK as ae,cL as J,u as ne,a3 as W,cG as h,cJ as D,c9 as x,cn as R,cM as $,h as re,a5 as se,B as b,cf as L,bF as T,bV as G,ce as ie,cm as oe,bP as v,a2 as p,a4 as _,cN as ce,bW as q,cF as le,bS as Q,cg as ue,cO as O,cP as de,cQ as N,cR as me,cS as j,cT as pe}from"./index-4dSMX-rY.js";import{M as B}from"./index-BSEJ9kNR.js";import{S as K,E as ye}from"./assertEnabled-69ed68b5.browser.esm-a3yHtrnb.js";import{N as E}from"./setErc20Allowance-bae9b83c.browser.esm-DD2nPoyZ.js";function ve(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerTransaction:e.maxClaimablePerWallet,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims||0}}function Ue(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot,pricePerToken:e.pricePerToken,currency:e.currency,quantityLimitPerWallet:e.maxClaimablePerWallet,metadata:e.metadata||""}}function P(e,t){return e==="unlimited"?x:R(e,t)}async function Y(e){const a=Array.from({length:Math.ceil(e.length/25e3)},(s,o)=>e.slice(o*25e3,o*25e3+25e3)),r=[],n=await Promise.all(a.map(s=>j.parseAsync(s)));for(const s of n)r.push(...s);return r}const he=2;let U=function(e){return e[e.V1=1]="V1",e[e.V2=2]="V2",e}({});class f{constructor(t,a,r,n,s){this.storage=t,this.shardNybbles=n,this.baseUri=a,this.originalEntriesUri=r,this.tokenDecimals=s,this.shards={},this.trees={}}static async fromUri(t,a){try{const r=await a.downloadJSON(t);if(r.isShardedMerkleTree)return f.fromShardedMerkleTreeInfo(r,a)}catch{return}}static async fromShardedMerkleTreeInfo(t,a){return new f(a,t.baseUri,t.originalEntriesUri,t.shardNybbles,t.tokenDecimals)}static hashEntry(t,a,r,n){switch(n){case U.V1:return Q(["address","uint256"],[t.address,P(t.maxClaimable,a)]);case U.V2:return Q(["address","uint256","uint256","address"],[t.address,P(t.maxClaimable,a),P(t.price||"unlimited",r),t.currencyAddress||T])}}static async fetchAndCacheDecimals(t,a,r){if(!r)return 18;let n=t[r];return n===void 0&&(n=(await ue(a,r)).decimals,t[r]=n),n}static async buildAndUpload(t,a,r,n,s){let o=arguments.length>5&&arguments[5]!==void 0?arguments[5]:he;const i=await Y(t),c={};for(const C of i){const g=C.address.slice(2,2+o).toLowerCase();c[g]===void 0&&(c[g]=[]),c[g].push(C)}const u={},d=await Promise.all(Object.entries(c).map(async C=>{let[g,M]=C;return[g,new B(await Promise.all(M.map(async A=>{const te=await f.fetchAndCacheDecimals(u,r,A.currencyAddress);return f.hashEntry(A,a,te,s)})),O,{sort:!0}).getHexRoot()]})),l=Object.fromEntries(d),y=new B(Object.values(l),O,{sort:!0}),w=[];for(const[C,g]of Object.entries(c)){const M={proofs:y.getProof(l[C]).map(A=>"0x"+A.data.toString("hex")),entries:g};w.push({data:JSON.stringify(M),name:`${C}.json`})}const S=await n.uploadBatch(w),k=S[0].slice(0,S[0].lastIndexOf("/")),m=await n.upload(i),z={merkleRoot:y.getHexRoot(),baseUri:k,originalEntriesUri:m,shardNybbles:o,tokenDecimals:a,isShardedMerkleTree:!0},ee=await n.upload(z);return{shardedMerkleInfo:z,uri:ee}}async getProof(t,a,r){const n=t.slice(2,2+this.shardNybbles).toLowerCase();let s=this.shards[n];const o={};if(s===void 0)try{const l=this.baseUri.endsWith("/")?this.baseUri:`${this.baseUri}/`;s=this.shards[n]=await this.storage.downloadJSON(`${l}${n}.json`);const y=await Promise.all(s.entries.map(async w=>{const S=await f.fetchAndCacheDecimals(o,a,w.currencyAddress);return f.hashEntry(w,this.tokenDecimals,S,r)}));this.trees[n]=new B(y,O,{sort:!0})}catch{return null}const i=s.entries.find(l=>l.address.toLowerCase()===t.toLowerCase());if(!i)return null;const c=await f.fetchAndCacheDecimals(o,a,i.currencyAddress),u=f.hashEntry(i,this.tokenDecimals,c,r),d=this.trees[n].getProof(u).map(l=>"0x"+l.data.toString("hex"));return de.parseAsync({...i,proof:d.concat(s.proofs)})}async getAllEntries(){try{return await this.storage.downloadJSON(this.originalEntriesUri)}catch(t){return console.warn("Could not fetch original snapshot entries",t),[]}}}async function fe(e,t,a,r,n,s){if(!a)return null;const o=a[t];if(o){const i=await n.downloadJSON(o);if(i.isShardedMerkleTree&&i.merkleRoot===t)return await(await f.fromShardedMerkleTreeInfo(i,n)).getProof(e,r,s);const c=await $.parseAsync(i);if(t===c.merkleRoot)return c.claims.find(u=>u.address.toLowerCase()===e.toLowerCase())||null}return null}function We(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerTransaction,waitTimeInSecondsBetweenClaims:e.waitTimeInSecondsBetweenClaims}}function De(e){return{startTimestamp:e.startTimestamp,maxClaimableSupply:e.maxClaimableSupply,supplyClaimed:e.supplyClaimed,merkleRoot:e.merkleRoot.toString(),pricePerToken:e.pricePerToken,currency:e.currency,maxClaimablePerWallet:e.quantityLimitPerWallet,waitTimeInSecondsBetweenClaims:0,metadata:e.metadata}}async function Se(e,t,a,r,n){const s=e.getSigner(),o=e.getProvider(),i=(await re(async()=>{const{default:w}=await import("./index-4dSMX-rY.js").then(S=>S.ir);return{default:w}},__vite__mapDeps([0,1]))).default,c=new se(s||o,t,i,e.options,e.storage),u=await e.getSignerAddress(),d=e.address,l=await c.read("allowance",[u,d]),y=b.from(a).mul(b.from(r)).div(R("1",n));l.lt(y)&&await c.sendTransaction("approve",[d,l.add(y)])}async function Le(e,t,a,r,n,s,o,i,c){let u=P(a.maxClaimablePerWallet,n),d=[L([0],32)],l=a.price,y=a.currencyAddress;try{if(!a.merkleRootHash.toString().startsWith(T)){const m=await fe(e,a.merkleRootHash.toString(),await r(),s.getProvider(),o,c);if(m)d=m.proof,u=m.maxClaimable==="unlimited"?x:R(m.maxClaimable,n),l=m.price===void 0||m.price==="unlimited"?x:await G(s.getProvider(),m.price,m.currencyAddress||T),y=m.currencyAddress||T;else if(c===U.V1)throw new Error("No claim found for this address")}}catch(m){if((m==null?void 0:m.message)==="No claim found for this address")throw m;console.warn("failed to check claim condition merkle root hash, continuing anyways",m)}const w=await s.getCallOverrides()||{},S=l.toString()!==x.toString()?l:a.price,k=y!==T?y:a.currencyAddress;return S.gt(0)&&(ie(k)?w.value=b.from(S).mul(t).div(R("1",n)):i&&await Se(s,k,S,t,n)),{overrides:w,proofs:d,maxClaimable:u,price:S,currencyAddress:k,priceInProof:l,currencyAddressInProof:y}}const we=p.object({name:p.string(),symbol:p.string(),decimals:p.number()}),Te=we.extend({value:h,displayValue:p.string()}),be=p.object({name:p.string().optional()}).catchall(p.unknown()),H=p.object({startTime:K,currencyAddress:p.string().default(q),price:W.default(0),maxClaimableSupply:N,maxClaimablePerWallet:N,waitInSeconds:D.default(0),merkleRootHash:me.default(L([0],32)),snapshot:p.optional(j).nullable(),metadata:be.optional()}),Ce=p.array(H),Z=H.extend({availableSupply:N,currentMintSupply:N,currencyMetadata:Te.default({value:b.from("0"),displayValue:"0",symbol:"",decimals:18,name:""}),price:h,waitInSeconds:h,startTime:h.transform(e=>new Date(e.toNumber()*1e3)),snapshot:j.optional().nullable()});async function ge(e,t,a,r,n){const s=await Y(e),o=s.map(u=>u.address);if(new Set(o).size<o.length)throw new pe;const c=await f.buildAndUpload(s,t,a,r,n);return{merkleRoot:c.shardedMerkleInfo.merkleRoot,snapshotUri:c.uri}}function Pe(e,t){const a=b.from(e),r=b.from(t);return a.eq(r)?0:a.gt(r)?1:-1}async function ke(e,t,a,r,n){const s=[];return{inputsWithSnapshots:await Promise.all(e.map(async i=>{if(i.snapshot&&i.snapshot.length>0){const c=await ge(i.snapshot,t,a,r,n);s.push(c),i.merkleRootHash=c.merkleRoot}else i.merkleRootHash=L([0],32);return i})),snapshotInfos:s}}async function xe(e,t,a,r){const n=e.currencyAddress===T?q:e.currencyAddress,s=P(e.maxClaimableSupply,t),o=P(e.maxClaimablePerWallet,t);let i;return e.metadata&&(typeof e.metadata=="string"?i=e.metadata:i=await r.upload(e.metadata)),{startTimestamp:e.startTime,maxClaimableSupply:s,supplyClaimed:0,maxClaimablePerWallet:o,pricePerToken:await G(a,e.price,n),currency:n,merkleRoot:e.merkleRootHash.toString(),waitTimeInSecondsBetweenClaims:e.waitInSeconds||0,metadata:i}}async function qe(e,t,a,r,n){const{inputsWithSnapshots:s,snapshotInfos:o}=await ke(e,t,a,r,n),i=await Ce.parseAsync(s),c=(await Promise.all(i.map(u=>xe(u,t,a,r)))).sort((u,d)=>Pe(u.startTimestamp,d.startTimestamp));return{snapshotInfos:o,sortedConditions:c}}async function Ae(e,t,a){if(!t)return null;const r=t[e];if(r){const n=await a.downloadJSON(r);if(n.isShardedMerkleTree&&n.merkleRoot===e){const s=await f.fromUri(r,a);return(s==null?void 0:s.getAllEntries())||null}else{const s=await $.parseAsync(n);if(e===s.merkleRoot)return s.claims.map(o=>({address:o.address,maxClaimable:o.maxClaimable,price:o.price,currencyAddress:o.currencyAddress}))}}return null}function I(e,t){return e.toString()===x.toString()?"unlimited":v(e,t)}async function je(e,t,a,r,n,s){var y;const o=await oe(a,e.currency,e.pricePerToken),i=I(e.maxClaimableSupply,t),c=I(e.maxClaimablePerWallet,t),u=I(b.from(e.maxClaimableSupply).sub(e.supplyClaimed),t),d=I(e.supplyClaimed,t);let l;return e.metadata&&(l=await n.downloadJSON(e.metadata)),Z.parseAsync({startTime:e.startTimestamp,maxClaimableSupply:i,maxClaimablePerWallet:c,currentMintSupply:d,availableSupply:u,waitInSeconds:(y=e.waitTimeInSecondsBetweenClaims)==null?void 0:y.toString(),price:b.from(e.pricePerToken),currency:e.currency,currencyAddress:e.currency,currencyMetadata:o,merkleRootHash:e.merkleRoot,snapshot:s?await Ae(e.merkleRoot,r,n):void 0,metadata:l})}async function He(e,t,a){if(e>=a.length)throw Error(`Index out of bounds - got index: ${e} with ${a.length} conditions`);const r=a[e].currencyMetadata.decimals,n=a[e].price,s=v(n,r),o=await H.parseAsync({...a[e],price:s,...t}),i=await Z.parseAsync({...o,price:n});return a.map((c,u)=>{let d;u===e?d=i:d=c;const l=v(d.price,r);return{...d,price:l}})}let Ve=function(e){return e.NotEnoughSupply="There is not enough supply to claim.",e.AddressNotAllowed="This address is not on the allowlist.",e.WaitBeforeNextClaimTransaction="Not enough time since last claim transaction. Please wait.",e.ClaimPhaseNotStarted="Claim phase has not started yet.",e.AlreadyClaimed="You have already claimed the token.",e.WrongPriceOrCurrency="Incorrect price or currency.",e.OverMaxClaimablePerWallet="Cannot claim more than maximum allowed quantity.",e.NotEnoughTokens="There are not enough tokens in the wallet to pay for the claim.",e.NoActiveClaimPhase="There is no active claim phase at the moment. Please check back in later.",e.NoClaimConditionSet="There is no claim condition set.",e.NoWallet="No wallet connected.",e.Unknown="No claim conditions found.",e}({});function Ie(e){if(e===void 0){const t=Buffer.alloc(16);return ae({},t),J(ne(t.toString("hex")))}else return J(e)}const X=p.object({to:_.refine(e=>e.toLowerCase()!==T,{message:"Cannot create payload to mint to zero address"}),price:W.default(0),currencyAddress:ce.default(q),mintStartTime:K,mintEndTime:ye,uid:p.string().optional().transform(e=>Ie(e)),primarySaleRecipient:_.default(T)}),Re=X.extend({quantity:W}),ze=Re.extend({mintStartTime:h,mintEndTime:h}),V=X.extend({metadata:E,royaltyRecipient:p.string().default(T),royaltyBps:le.default(0)}),F=V.extend({metadata:E.default(""),uri:p.string(),royaltyBps:h,mintStartTime:h,mintEndTime:h}),Ne=V.extend({metadata:E.default(""),quantity:D}),Je=Ne.extend({tokenId:D}),_e=F.extend({tokenId:h,quantity:h}),Qe=V.extend({metadata:E.default(""),quantity:h.default(1)}),$e=F.extend({quantity:h.default(1)}),Ge=[{name:"to",type:"address"},{name:"primarySaleRecipient",type:"address"},{name:"quantity",type:"uint256"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ke=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"price",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ye=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"tokenId",type:"uint256"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}],Ze=[{name:"to",type:"address"},{name:"royaltyRecipient",type:"address"},{name:"royaltyBps",type:"uint256"},{name:"primarySaleRecipient",type:"address"},{name:"uri",type:"string"},{name:"quantity",type:"uint256"},{name:"pricePerToken",type:"uint256"},{name:"currency",type:"address"},{name:"validityStartTimestamp",type:"uint128"},{name:"validityEndTimestamp",type:"uint128"},{name:"uid",type:"bytes32"}];export{X as B,Ve as C,Ye as M,Je as S,Se as a,_e as b,P as c,ve as d,Ue as e,fe as f,Le as g,U as h,Re as i,ze as j,Ge as k,We as l,Qe as m,De as n,$e as o,qe as p,Ke as q,Ie as r,Ze as s,je as t,He as u};
