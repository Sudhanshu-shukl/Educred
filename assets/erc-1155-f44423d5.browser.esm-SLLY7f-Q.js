const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index-4dSMX-rY.js","assets/index-Ch0Y1xiN.css"])))=>i.map(i=>d[i]);
var et=Object.defineProperty;var nt=(y,t,r)=>t in y?et(y,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):y[t]=r;var l=(y,t,r)=>nt(y,typeof t!="symbol"?t+"":t,r);import{fm as it,B as T,bF as j,fe as L,fn as st,d2 as m,d7 as h,d8 as b,dU as S,fo as v,fp as P,fq as G,fr as N,fs as K,ft as x,fu as J,fv as X,fw as q,fx as ot,a2 as I,fy as ct,c9 as D,G as lt,fz as tt,dK as pt,u as k,fA as B,cc as F,fB as ht,dL as dt,h as ut,c_ as mt,cf as gt,fC as ft,fD as wt}from"./index-4dSMX-rY.js";import{a as E}from"./assertEnabled-69ed68b5.browser.esm-il59lfEz.js";import{d as C,h as R,C as Ct}from"./contract-appuri-29f0e515.browser.esm-dl8biRXT.js";import{F as yt,a as Wt,u as _,D as O,b as Et}from"./QueryParams-fe3080d5.browser.esm-C-khf3_T.js";import{c as bt,D as Tt}from"./contract-owner-4df2a33b.browser.esm-C4sJMfVj.js";import{d as At}from"./index-BSEJ9kNR.js";import{S as St,b as Mt,M as vt,t as U,l as z,n as V,C as w,c as $,f as Pt,p as Nt,d as Q,e as Z,u as It,g as Dt,h as H}from"./signature-f370b04e.browser.esm-0sJIU-jq.js";import{s as Rt}from"./setErc20Allowance-bae9b83c.browser.esm-BpTPtwxZ.js";class Lt{constructor(t,r,e){l(this,"set",h((()=>{var t=this;return async function(r,e){let a=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;return t.setBatch.prepare([{tokenId:r,claimConditions:e}],a)}})()));l(this,"setBatch",h((()=>{var t=this;return async function(r){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;const a={},n=await Promise.all(r.map(async s=>{let{tokenId:p,claimConditions:d}=s,f=d;if(t.isLegacySinglePhaseDrop(t.contractWrapper)){if(e=!0,d.length===0)f=[{startTime:new Date(0),currencyAddress:j,price:0,maxClaimableSupply:0,maxClaimablePerWallet:0,waitInSeconds:0,merkleRootHash:gt([0],32),snapshot:[]}];else if(d.length>1)throw new Error("Single phase drop contract cannot have multiple claim conditions, only one is allowed")}(t.isNewSinglePhaseDrop(t.contractWrapper)||t.isNewMultiphaseDrop(t.contractWrapper))&&f.forEach(o=>{var W;if(o.snapshot&&o.snapshot.length>0&&(o.maxClaimablePerWallet===void 0||o.maxClaimablePerWallet==="unlimited"))throw new Error(`maxClaimablePerWallet must be set to a specific value when an allowlist is set.
Set it to 0 to only allow addresses in the allowlist to claim the amount specified in the allowlist.

ex:
contract.claimConditions.set(tokenId, [{ snapshot: [{ address: '0x...', maxClaimable: 1 }], maxClaimablePerWallet: 0 }])`);if(o.snapshot&&o.snapshot.length>0&&((W=o.maxClaimablePerWallet)==null?void 0:W.toString())==="0"&&o.snapshot.map(A=>{var M;return typeof A=="string"?0:Number(((M=A.maxClaimable)==null?void 0:M.toString())||0)}).reduce((A,M)=>A+M,0)===0)throw new Error("maxClaimablePerWallet is set to 0, and all addresses in the allowlist have max claimable 0. This means that no one can claim.")});const{snapshotInfos:g,sortedConditions:u}=await Nt(f,0,t.contractWrapper.getProvider(),t.storage,t.getSnapshotFormatVersion());return g.forEach(o=>{a[o.merkleRoot]=o.snapshotUri}),{tokenId:p,sortedConditions:u}})),i=await t.metadata.get(),c=[];for(const s of Object.keys(i.merkle||{}))a[s]=i.merkle[s];if(!At(i.merkle,a)){const s=await t.metadata.parseInputMetadata({...i,merkle:a}),p=await t.metadata._parseAndUploadMetadata(s);if(R("setContractURI",t.contractWrapper)){const d=new S(t.contractWrapper);c.push(d.encode("setContractURI",[p]))}else throw new Error("Setting a merkle root requires implementing ContractMetadata in your contract to support storing a merkle root.")}if(n.forEach(s=>{let{tokenId:p,sortedConditions:d}=s;const f=new S(t.contractWrapper);if(t.isLegacySinglePhaseDrop(t.contractWrapper)){const g=new S(t.contractWrapper);c.push(g.encode("setClaimConditions",[p,Q(d[0]),e]))}else if(t.isLegacyMultiPhaseDrop(t.contractWrapper))c.push(f.encode("setClaimConditions",[p,d.map(Q),e]));else if(t.isNewSinglePhaseDrop(t.contractWrapper))c.push(f.encode("setClaimConditions",[p,Z(d[0]),e]));else if(t.isNewMultiphaseDrop(t.contractWrapper))c.push(f.encode("setClaimConditions",[p,d.map(Z),e]));else throw new Error("Contract does not support claim conditions")}),R("multicall",t.contractWrapper))return b.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[c]});throw new Error("Contract does not support multicall")}})()));l(this,"update",h(async(t,r,e)=>{const a=await this.getAll(t),n=await It(r,e,a);return await this.set.prepare(t,n)}));this.storage=e,this.contractWrapper=t,this.metadata=r}async getActive(t,r){const e=await this.get(t),a=await this.metadata.get();return await U(e,0,this.contractWrapper.getProvider(),a.merkle,this.storage,(r==null?void 0:r.withAllowList)||!1)}async get(t,r){if(this.isLegacySinglePhaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("claimCondition",[t]);return z(e)}else if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){const e=r!==void 0?r:await this.contractWrapper.read("getActiveClaimConditionId",[t]),a=await this.contractWrapper.read("getClaimConditionById",[t,e]);return z(a)}else if(this.isNewSinglePhaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("claimCondition",[t]);return V(e)}else if(this.isNewMultiphaseDrop(this.contractWrapper)){const e=r!==void 0?r:await this.contractWrapper.read("getActiveClaimConditionId",[t]),a=await this.contractWrapper.read("getClaimConditionById",[t,e]);return V(a)}else throw new Error("Contract does not support claim conditions")}async getAll(t,r){if(this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){const e=await this.contractWrapper.read("claimCondition",[t]),a=e.currentStartId.toNumber(),n=e.count.toNumber(),i=[];for(let s=a;s<a+n;s++)i.push(await this.get(t,s));const c=await this.metadata.get();return Promise.all(i.map(s=>U(s,0,this.contractWrapper.getProvider(),c.merkle,this.storage,(r==null?void 0:r.withAllowList)||!1)))}else return[await this.getActive(t,r)]}async canClaim(t,r,e){return e&&(e=await m(e)),(await this.getClaimIneligibilityReasons(t,r,e)).length===0}async getClaimIneligibilityReasons(t,r,e){const a=[];let n,i;if(e===void 0)try{e=await this.contractWrapper.getSignerAddress()}catch(o){console.warn("failed to get signer address",o)}if(!e)return[w.NoWallet];const c=await m(e);try{i=await this.getActive(t)}catch(o){return B(o,"!CONDITION")||B(o,"no active mint condition")?(a.push(w.NoClaimConditionSet),a):(a.push(w.Unknown),a)}if(i.availableSupply!=="unlimited"&&T.from(i.availableSupply).lt(r))return a.push(w.NotEnoughSupply),a;const p=F(i.merkleRootHash).length>0;let d=null;if(p){if(d=await this.getClaimerProofs(t,c),!d&&(this.isLegacySinglePhaseDrop(this.contractWrapper)||this.isLegacyMultiPhaseDrop(this.contractWrapper)))return a.push(w.AddressNotAllowed),a;if(d)try{const o=await this.prepareClaim(t,r,!1,c);let W;if(this.isLegacyMultiPhaseDrop(this.contractWrapper)){if(n=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[W]=await this.contractWrapper.read("verifyClaimMerkleProof",[n,c,t,r,o.proofs,o.maxClaimable]),!W)return a.push(w.AddressNotAllowed),a}else if(this.isLegacySinglePhaseDrop(this.contractWrapper)){if([W]=await this.contractWrapper.read("verifyClaimMerkleProof",[t,c,r,{proof:o.proofs,maxQuantityInAllowlist:o.maxClaimable}]),!W)return a.push(w.AddressNotAllowed),a}else this.isNewSinglePhaseDrop(this.contractWrapper)?await this.contractWrapper.read("verifyClaim",[t,c,r,o.currencyAddress,o.price,{proof:o.proofs,quantityLimitPerWallet:o.maxClaimable,currency:o.currencyAddressInProof,pricePerToken:o.priceInProof}]):this.isNewMultiphaseDrop(this.contractWrapper)&&(n=await this.contractWrapper.read("getActiveClaimConditionId",[t]),await this.contractWrapper.read("verifyClaim",[n,c,t,r,o.currencyAddress,o.price,{proof:o.proofs,quantityLimitPerWallet:o.maxClaimable,currency:o.currencyAddressInProof,pricePerToken:o.priceInProof}]))}catch(o){switch(console.warn("Merkle proof verification failed:","reason"in o?o.reason:o),o.reason){case"!Qty":a.push(w.OverMaxClaimablePerWallet);break;case"!PriceOrCurrency":a.push(w.WrongPriceOrCurrency);break;case"!MaxSupply":a.push(w.NotEnoughSupply);break;case"cant claim yet":a.push(w.ClaimPhaseNotStarted);break;default:{a.push(w.AddressNotAllowed);break}}return a}}if(this.isNewSinglePhaseDrop(this.contractWrapper)||this.isNewMultiphaseDrop(this.contractWrapper)){let o=T.from(0),W=$(i.maxClaimablePerWallet,0);try{o=await this.getSupplyClaimedByWallet(t,c)}catch{}if(d&&(W=$(d.maxClaimable,0)),W.gt(0)&&W.lt(o.add(r)))return a.push(w.OverMaxClaimablePerWallet),a;if((!p||p&&!d)&&(W.lte(o)||W.eq(0)))return a.push(w.AddressNotAllowed),a}let[f,g]=[T.from(0),T.from(0)];this.isLegacyMultiPhaseDrop(this.contractWrapper)?(n=await this.contractWrapper.read("getActiveClaimConditionId",[t]),[f,g]=await this.contractWrapper.read("getClaimTimestamp",[t,n,c])):this.isLegacySinglePhaseDrop(this.contractWrapper)&&([f,g]=await this.contractWrapper.read("getClaimTimestamp",[t,c]));const u=T.from(Date.now()).div(1e3);if(f.gt(0)&&u.lt(g))return g.eq(D)?a.push(w.AlreadyClaimed):a.push(w.WaitBeforeNextClaimTransaction),a;if(i.price.gt(0)&&ht()){const o=i.price.mul(r),W=this.contractWrapper.getProvider();if(dt(i.currencyAddress))(await W.getBalance(c)).lt(o)&&a.push(w.NotEnoughTokens);else{const A=(await ut(async()=>{const{default:rt}=await import("./index-4dSMX-rY.js").then(at=>at.ir);return{default:rt}},__vite__mapDeps([0,1]))).default;(await new mt(W,i.currencyAddress,A,{},this.storage).read("balanceOf",[c])).lt(o)&&a.push(w.NotEnoughTokens)}}return a}async getClaimerProofs(t,r,e){const n=(await this.get(t,e)).merkleRoot;if(F(n).length>0){const c=await this.metadata.get(),s=await m(r);return await Pt(s,n.toString(),c.merkle,this.contractWrapper.getProvider(),this.storage,this.getSnapshotFormatVersion())}else return null}async getSupplyClaimedByWallet(t,r){const e=await m(r);if(this.isNewSinglePhaseDrop(this.contractWrapper))return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,e]);if(this.isNewMultiphaseDrop(this.contractWrapper)){const a=await this.contractWrapper.read("getActiveClaimConditionId",[t]);return await this.contractWrapper.read("getSupplyClaimedByWallet",[t,a,e])}throw new Error("This contract does not support the getSupplyClaimedByWallet function")}async prepareClaim(t,r,e,a){const n=await m(a||await this.contractWrapper.getSignerAddress());return Dt(n,r,await this.getActive(t),async()=>(await this.metadata.get()).merkle,0,this.contractWrapper,this.storage,e,this.getSnapshotFormatVersion())}async getClaimArguments(t,r,e,a){const n=await m(r);return this.isLegacyMultiPhaseDrop(this.contractWrapper)?[n,t,e,a.currencyAddress,a.price,a.proofs,a.maxClaimable]:this.isLegacySinglePhaseDrop(this.contractWrapper)?[n,t,e,a.currencyAddress,a.price,{proof:a.proofs,maxQuantityInAllowlist:a.maxClaimable},k("")]:[n,t,e,a.currencyAddress,a.price,{proof:a.proofs,quantityLimitPerWallet:a.maxClaimable,pricePerToken:a.priceInProof,currency:a.currencyAddressInProof},k("")]}async getClaimTransaction(t,r,e,a){if(a!=null&&a.pricePerToken)throw new Error("Price per token should be set via claim conditions by calling `contract.erc1155.claimConditions.set()`");const n=await this.prepareClaim(r,e,(a==null?void 0:a.checkERC20Allowance)||!0);return b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:await this.getClaimArguments(r,t,e,n),overrides:n.overrides})}isNewSinglePhaseDrop(t){return C(t,"ERC1155ClaimConditionsV2")}isNewMultiphaseDrop(t){return C(t,"ERC1155ClaimPhasesV2")}isLegacySinglePhaseDrop(t){return C(t,"ERC1155ClaimConditionsV1")}isLegacyMultiPhaseDrop(t){return C(t,"ERC1155ClaimPhasesV1")}getSnapshotFormatVersion(){return this.isLegacyMultiPhaseDrop(this.contractWrapper)||this.isLegacySinglePhaseDrop(this.contractWrapper)?H.V1:H.V2}}const Y=I.object({address:ft,quantity:wt.default(1)}),xt=I.union([I.array(I.string()).transform(async y=>await Promise.all(y.map(t=>Y.parseAsync({address:t})))),I.array(Y)]);class kt{constructor(t){l(this,"featureName",x.name);l(this,"to",h(async(t,r,e,a)=>await this.getClaimTransaction(t,r,e,a)));this.contractWrapper=t}async getClaimTransaction(t,r,e,a){let n={};return a&&a.pricePerToken&&(n=await bt(this.contractWrapper,a.pricePerToken,e,a.currencyAddress,a.checkERC20Allowance)),b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"claim",args:[await m(t),r,e],overrides:n})}}class _t{constructor(t,r){l(this,"featureName",J.name);l(this,"to",h(async(t,r,e,a)=>await this.conditions.getClaimTransaction(t,r,e,a)));this.contractWrapper=t,this.storage=r;const e=new Ct(this.contractWrapper,ct,this.storage);this.conditions=new Lt(t,e,this.storage)}}class Bt{constructor(t,r,e){l(this,"featureName",X.name);l(this,"mint",h(async t=>{const r=t.payload,e=t.signature,[a,n]=await Promise.all([this.mapPayloadToContractStruct(r),this.contractWrapper.getCallOverrides()]);return await Rt(this.contractWrapper,a.pricePerToken.mul(a.quantity),r.currencyAddress,n),b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintWithSignature",args:[a,e],overrides:n,parse:i=>{const c=this.contractWrapper.parseLogs("TokensMintedWithSignature",i.logs);if(c.length===0)throw new Error("No MintWithSignature event found");return{id:c[0].args.tokenIdMinted,receipt:i}}})}));l(this,"mintBatch",h(async t=>{const r=await Promise.all(t.map(i=>this.mapPayloadToContractStruct(i.payload))),e=t.map((i,c)=>{const s=r[c],p=i.signature,d=i.payload.price;if(T.from(d).gt(0))throw new Error("Can only batch free mints. For mints with a price, use regular mint()");return{message:s,signature:p}}),a=new S(this.contractWrapper),n=e.map(i=>a.encode("mintWithSignature",[i.message,i.signature]));if(R("multicall",this.contractWrapper))return b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[n],parse:i=>{const c=this.contractWrapper.parseLogs("TokensMintedWithSignature",i.logs);if(c.length===0)throw new Error("No MintWithSignature event found");return c.map(s=>({id:s.args.tokenIdMinted,receipt:i}))}});throw new Error("Multicall not supported on this contract!")}));this.contractWrapper=t,this.storage=r,this.roles=e}async verify(t){const r=t.payload,e=t.signature,a=await this.mapPayloadToContractStruct(r);return(await this.contractWrapper.read("verify",[a,e]))[0]}async generate(t){const r={...t,tokenId:D};return this.generateFromTokenId(r)}async generateFromTokenId(t){return(await this.generateBatchFromTokenIds([t]))[0]}async generateBatch(t){const r=t.map(e=>({...e,tokenId:D}));return this.generateBatchFromTokenIds(r)}async generateBatchFromTokenIds(t){var g;const r=this.contractWrapper.getSigner();lt(r),await((g=this.roles)==null?void 0:g.verify(["minter"],await r.getAddress()));const e=await Promise.all(t.map(u=>St.parseAsync(u))),a=e.map(u=>u.metadata),[n,i,c]=await Promise.all([_(a,this.storage),this.contractWrapper.getChainID(),tt(this.contractWrapper.address,this.contractWrapper.getProvider())]),s=await Promise.all(e.map((u,o)=>Mt.parseAsync({...u,uri:n[o]}))),p=await Promise.all(s.map(u=>this.mapPayloadToContractStruct(u))),d=(c==null?void 0:c.type)==="TokenERC1155";return(await Promise.all(p.map(u=>this.contractWrapper.signTypedData(r,{name:d?"TokenERC1155":"SignatureMintERC1155",version:"1",chainId:i,verifyingContract:this.contractWrapper.address},{MintRequest:vt},u)))).map((u,o)=>({payload:s[o],signature:u.toString()}))}async mapPayloadToContractStruct(t){const r=await pt(this.contractWrapper.getProvider(),t.price,t.currencyAddress);return{to:t.to,tokenId:t.tokenId,uri:t.uri,quantity:t.quantity,pricePerToken:r,currency:t.currencyAddress,validityStartTimestamp:t.mintStartTime,validityEndTimestamp:t.mintEndTime,uid:t.uid,royaltyRecipient:t.royaltyRecipient,royaltyBps:t.royaltyBps,primarySaleRecipient:t.primarySaleRecipient}}}class Ft{constructor(t){l(this,"featureName",N.name);l(this,"tokens",h(async(t,r)=>{const e=await this.contractWrapper.getSignerAddress();return this.from.prepare(e,t,r)}));l(this,"from",h(async(t,r,e)=>b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burn",args:[await m(t),r,e]})));l(this,"batch",h(async(t,r)=>{const e=await this.contractWrapper.getSignerAddress();return this.batchFrom.prepare(e,t,r)}));l(this,"batchFrom",h(async(t,r,e)=>b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"burnBatch",args:[await m(t),r,e]})));this.contractWrapper=t}}class Ot{constructor(t,r){l(this,"featureName",v.name);this.erc1155=t,this.contractWrapper=r}async all(t){const r=T.from((t==null?void 0:t.start)||0).toNumber(),e=T.from((t==null?void 0:t.count)||O).toNumber(),a=Math.min((await this.totalCount()).toNumber(),r+e);return await Promise.all([...Array(a-r).keys()].map(n=>this.erc1155.get((r+n).toString())))}async totalCount(){return await this.contractWrapper.read("nextTokenIdToMint",[])}async totalCirculatingSupply(t){return await this.contractWrapper.read("totalSupply",[t])}async owned(t,r){const[e,a]=await Promise.all([m(t||await this.contractWrapper.getSignerAddress()),this.contractWrapper.read("nextTokenIdToMint",[])]);let i=(await this.contractWrapper.read("balanceOfBatch",[Array(a.toNumber()).fill(e),Array.from(Array(a.toNumber()).keys())])).map((s,p)=>({tokenId:p,balance:s})).filter(s=>s.balance.gt(0));if(r){const s=(r==null?void 0:r.start)||0,p=(r==null?void 0:r.count)||O;i=i.slice(s,s+p)}return(await Promise.all(i.map(s=>this.erc1155.get(s.tokenId.toString())))).map((s,p)=>({...s,owner:e,quantityOwned:i[p].balance.toString()}))}}class Ut{constructor(t,r,e){l(this,"featureName",K.name);l(this,"lazyMint",h(async(t,r)=>{const e=await this.erc1155.nextTokenIdToMint(),a=await _(t,this.storage,e.toNumber(),r),n=a[0].substring(0,a[0].lastIndexOf("/"));for(let s=0;s<a.length;s++){const p=a[s].substring(0,a[s].lastIndexOf("/"));if(n!==p)throw new Error(`Can only create batches with the same base URI for every entry in the batch. Expected '${n}' but got '${p}'`)}const i=s=>{const p=this.contractWrapper.parseLogs("TokensLazyMinted",s==null?void 0:s.logs),d=p[0].args.startTokenId,f=p[0].args.endTokenId,g=[];for(let u=d;u.lte(f);u=u.add(1))g.push({id:u,receipt:s,data:()=>this.erc1155.getTokenMetadata(u)});return g},c=await tt(this.contractWrapper.address,this.contractWrapper.getProvider());return this.isLegacyEditionDropContract(this.contractWrapper,c)?b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${n.endsWith("/")?n:`${n}/`}`],parse:i}):b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"lazyMint",args:[a.length,`${n.endsWith("/")?n:`${n}/`}`,k("")],parse:i})}));this.erc1155=t,this.contractWrapper=r,this.storage=e,this.revealer=this.detectErc1155Revealable()}detectErc1155Revealable(){if(C(this.contractWrapper,"ERC1155Revealable"))return new Tt(this.contractWrapper,this.storage,q.name,()=>this.erc1155.nextTokenIdToMint())}isLegacyEditionDropContract(t,r){return r&&r.type==="DropERC1155"&&r.version<3||!1}}class zt{constructor(t,r,e){l(this,"featureName",G.name);l(this,"to",h(async(t,r)=>{const e=r.map(p=>p.metadata),a=r.map(p=>p.supply),n=await _(e,this.storage),i=await m(t),c=new S(this.contractWrapper),s=await Promise.all(n.map(async(p,d)=>c.encode("mintTo",[i,D,p,a[d]])));return b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[s],parse:p=>{const d=this.contractWrapper.parseLogs("TokensMinted",p.logs);if(d.length===0||d.length<e.length)throw new Error("TokenMinted event not found, minting failed");return d.map(f=>{const g=f.args.tokenIdMinted;return{id:g,receipt:p,data:()=>this.erc1155.get(g)}})}})}));this.erc1155=t,this.contractWrapper=r,this.storage=e}}class Vt{constructor(t,r,e){l(this,"featureName",P.name);l(this,"to",h(async(t,r)=>{const e=await this.getMintTransaction(t,r);return e.setParse(a=>{const n=this.contractWrapper.parseLogs("TransferSingle",a==null?void 0:a.logs);if(n.length===0)throw new Error("TransferSingleEvent event not found");const i=n[0].args.id;return{id:i,receipt:a,data:()=>this.erc1155.get(i.toString())}}),e}));l(this,"additionalSupplyTo",h(async(t,r,e)=>{const a=await this.erc1155.getTokenMetadata(r);return b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await m(t),r,a.uri,e],parse:n=>({id:T.from(r),receipt:n,data:()=>this.erc1155.get(r)})})}));this.erc1155=t,this.contractWrapper=r,this.storage=e,this.batch=this.detectErc1155BatchMintable()}async getMintTransaction(t,r){const e=await Et(r.metadata,this.storage);return b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"mintTo",args:[await m(t),D,e,r.supply]})}detectErc1155BatchMintable(){if(C(this.contractWrapper,"ERC1155BatchMintable"))return new zt(this.erc1155,this.contractWrapper,this.storage)}}class qt{constructor(t,r,e){l(this,"featureName",it.name);l(this,"transfer",h((()=>{var t=this;return async function(r,e,a){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:[0];const i=await t.contractWrapper.getSignerAddress();return b.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[i,await m(r),e,a,n]})}})()));l(this,"transferBatch",h((()=>{var t=this;return async function(r,e,a,n){let i=arguments.length>4&&arguments[4]!==void 0?arguments[4]:[0];const c=n?await m(n):await t.contractWrapper.getSignerAddress();return b.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeBatchTransferFrom",args:[c,await m(r),e,a,i]})}})()));l(this,"transferFrom",h((()=>{var t=this;return async function(r,e,a,n){let i=arguments.length>4&&arguments[4]!==void 0?arguments[4]:[0];return b.fromContractWrapper({contractWrapper:t.contractWrapper,method:"safeTransferFrom",args:[await m(r),await m(e),a,n,i]})}})()));l(this,"setApprovalForAll",h(async(t,r)=>b.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setApprovalForAll",args:[t,r]})));l(this,"airdrop",h((()=>{var t=this;return async function(r,e,a){let n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:[0];const i=a?await m(a):await t.contractWrapper.getSignerAddress(),c=await t.balanceOf(i,r),s=await xt.parseAsync(e),p=s.reduce((g,u)=>T.from(g).add(T.from((u==null?void 0:u.quantity)||1)),T.from(0));if(c.lt(T.from(p)))throw new Error(`The caller owns ${c.toString()} NFTs, but wants to airdrop ${p.toString()} NFTs.`);const d=new S(t.contractWrapper),f=s.map(g=>{let{address:u,quantity:o}=g;return d.encode("safeTransferFrom",[i,u,r,o,n])});return b.fromContractWrapper({contractWrapper:t.contractWrapper,method:"multicall",args:[f]})}})()));l(this,"mint",h(async t=>this.mintTo.prepare(await this.contractWrapper.getSignerAddress(),t)));l(this,"mintTo",h(async(t,r)=>E(this.mintable,P).to.prepare(t,r)));l(this,"mintAdditionalSupply",h(async(t,r)=>E(this.mintable,P).additionalSupplyTo.prepare(await this.contractWrapper.getSignerAddress(),t,r)));l(this,"mintAdditionalSupplyTo",h(async(t,r,e)=>E(this.mintable,P).additionalSupplyTo.prepare(t,r,e)));l(this,"mintBatch",h(async t=>this.mintBatchTo.prepare(await this.contractWrapper.getSignerAddress(),t)));l(this,"mintBatchTo",h(async(t,r)=>{var e;return E((e=this.mintable)==null?void 0:e.batch,G).to.prepare(t,r)}));l(this,"burn",h(async(t,r)=>E(this.burnable,N).tokens.prepare(t,r)));l(this,"burnFrom",h(async(t,r,e)=>E(this.burnable,N).from.prepare(t,r,e)));l(this,"burnBatch",h(async(t,r)=>E(this.burnable,N).batch.prepare(t,r)));l(this,"burnBatchFrom",h(async(t,r,e)=>E(this.burnable,N).batchFrom.prepare(t,r,e)));l(this,"lazyMint",h(async(t,r)=>E(this.lazyMintable,K).lazyMint.prepare(t,r)));l(this,"claim",h(async(t,r,e)=>this.claimTo.prepare(await this.contractWrapper.getSignerAddress(),t,r,e)));l(this,"claimTo",h(async(t,r,e,a)=>{const n=this.claimWithConditions,i=this.claimCustom;if(n)return n.to.prepare(t,r,e,a);if(i)return i.to.prepare(t,r,e,a);throw new L(x)}));this.contractWrapper=t,this.storage=r,this.query=this.detectErc1155Enumerable(),this.mintable=this.detectErc1155Mintable(),this.burnable=this.detectErc1155Burnable(),this.lazyMintable=this.detectErc1155LazyMintable(),this.signatureMintable=this.detectErc1155SignatureMintable(),this.claimCustom=this.detectErc1155Claimable(),this.claimWithConditions=this.detectErc1155ClaimableWithConditions(),this._chainId=e}get chainId(){return this._chainId}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async get(t){const[r,e]=await Promise.all([this.contractWrapper.read("totalSupply",[t]).catch(()=>T.from(0)),this.getTokenMetadata(t).catch(()=>({id:t.toString(),uri:"",...yt}))]);return{owner:j,metadata:e,type:"ERC1155",supply:r.toString()}}async totalSupply(t){if(C(this.contractWrapper,"ERC1155Supply"))return await this.contractWrapper.read("totalSupply",[t]);throw new L(st)}async balanceOf(t,r){return await this.contractWrapper.read("balanceOf",[await m(t),r])}async balance(t){return await this.balanceOf(await this.contractWrapper.getSignerAddress(),t)}async isApproved(t,r){return await this.contractWrapper.read("isApprovedForAll",[await m(t),await m(r)])}async nextTokenIdToMint(){if(R("nextTokenIdToMint",this.contractWrapper))return await this.contractWrapper.read("nextTokenIdToMint",[]);throw new Error("Contract requires the `nextTokenIdToMint` function available to determine the next token ID to mint")}async getAll(t){return E(this.query,v).all(t)}async totalCount(){return E(this.query,v).totalCount()}async totalCirculatingSupply(t){return E(this.query,v).totalCirculatingSupply(t)}async getOwned(t,r){return t&&(t=await m(t)),E(this.query,v).owned(t,r)}async getMintTransaction(t,r){return E(this.mintable,P).getMintTransaction(t,r)}async getClaimTransaction(t,r,e,a){const n=this.claimWithConditions,i=this.claimCustom;if(n)return n.conditions.getClaimTransaction(t,r,e,a);if(i)return i.getClaimTransaction(t,r,e,a);throw new L(x)}get claimConditions(){return E(this.claimWithConditions,J).conditions}get signature(){return E(this.signatureMintable,X)}get revealer(){var t;return E((t=this.lazyMintable)==null?void 0:t.revealer,q)}async getTokenMetadata(t){const r=await this.contractWrapper.read("uri",[t]);if(!r)throw new ot;return Wt(t,r,this.storage)}detectErc1155Enumerable(){if(C(this.contractWrapper,"ERC1155Enumerable"))return new Ot(this,this.contractWrapper)}detectErc1155Mintable(){if(C(this.contractWrapper,"ERC1155Mintable"))return new Vt(this,this.contractWrapper,this.storage)}detectErc1155Burnable(){if(C(this.contractWrapper,"ERC1155Burnable"))return new Ft(this.contractWrapper)}detectErc1155LazyMintable(){if(C(this.contractWrapper,"ERC1155LazyMintableV1")||C(this.contractWrapper,"ERC1155LazyMintableV2"))return new Ut(this,this.contractWrapper,this.storage)}detectErc1155SignatureMintable(){if(C(this.contractWrapper,"ERC1155SignatureMintable"))return new Bt(this.contractWrapper,this.storage)}detectErc1155Claimable(){if(C(this.contractWrapper,"ERC1155ClaimCustom"))return new kt(this.contractWrapper)}detectErc1155ClaimableWithConditions(){if(C(this.contractWrapper,"ERC1155ClaimConditionsV1")||C(this.contractWrapper,"ERC1155ClaimConditionsV2")||C(this.contractWrapper,"ERC1155ClaimPhasesV1")||C(this.contractWrapper,"ERC1155ClaimPhasesV2"))return new _t(this.contractWrapper,this.storage)}}export{Lt as D,qt as E,Bt as a};
